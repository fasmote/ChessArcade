/*
 * Chessboard2.js - Versión local simplificada para Memory Matrix
 * Basada en la API de Chessboard2.js pero implementada específicamente para nuestras necesidades
 *
 * API Principal:
 * - Chessboard2('elementId', config) - Crear tablero
 * - board.position(fen) - Establecer posición
 * - board.position() - Obtener posición
 * - board.clear() - Limpiar tablero
 * - board.orientation() - Cambiar orientación
 * - board.resize() - Redimensionar
 */

(function() {
  'use strict';

  // ============================================
  // CONFIGURACIÓN Y CONSTANTES
  // ============================================

  // Mapeo de tipos de piezas para FEN
  var PIECE_TYPES = {
    'K': 'king', 'Q': 'queen', 'R': 'rook',
    'B': 'bishop', 'N': 'knight', 'P': 'pawn',
    'k': 'king', 'q': 'queen', 'r': 'rook',
    'b': 'bishop', 'n': 'knight', 'p': 'pawn'
  };

  // Símbolos Unicode para las piezas (fallback si no hay imágenes)
  var PIECE_SYMBOLS = {
    'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
    'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
  };

  // Archivos y rangos del tablero
  var FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
  var RANKS = ['1', '2', '3', '4', '5', '6', '7', '8'];

  // ============================================
  // CONSTRUCTOR PRINCIPAL
  // ============================================

  /**
   * Constructor principal de Chessboard2
   * @param {string|HTMLElement} container - ID del elemento o elemento DOM
   * @param {Object} config - Configuración del tablero
   */
  function Chessboard2(container, config) {
    // Obtener elemento DOM
    var element = typeof container === 'string' ?
                  document.getElementById(container) : container;

    if (!element) {
      throw new Error('Chessboard2: No se encontró el elemento contenedor');
    }

    // Configuración por defecto
    var defaultConfig = {
      position: 'start',           // Posición inicial ('start' o FEN string)
      orientation: 'white',        // Orientación del tablero
      showNotation: true,          // Mostrar coordenadas a-h, 1-8
      draggable: true,            // Permitir drag & drop
      dropOffBoard: 'trash',      // Qué hacer cuando se arrastra fuera
      pieceTheme: 'unicode',      // Tema de piezas ('unicode' o función)
      onDragStart: null,          // Callback al empezar drag
      onDrop: null,               // Callback al hacer drop
      onSnapEnd: null             // Callback al finalizar movimiento
    };

    // Combinar configuración por defecto con la proporcionada
    config = config || {};
    for (var key in defaultConfig) {
      if (config[key] === undefined) {
        config[key] = defaultConfig[key];
      }
    }

    // Estado interno del tablero
    var state = {
      element: element,
      config: config,
      position: {},               // Posición actual de las piezas
      orientation: config.orientation,
      squares: {},                // Referencias a elementos de casillas
      isDragging: false,         // Estado de arrastre
      draggedPiece: null         // Pieza siendo arrastrada
    };

    // ============================================
    // FUNCIONES DE UTILIDAD
    // ============================================

    /**
     * Convierte notación algebraica a coordenadas de array
     * Ejemplo: 'e4' -> {file: 4, rank: 3}
     */
    function algebraicToCoords(square) {
      return {
        file: square.charCodeAt(0) - 'a'.charCodeAt(0),
        rank: parseInt(square[1]) - 1
      };
    }

    /**
     * Convierte coordenadas de array a notación algebraica
     * Ejemplo: {file: 4, rank: 3} -> 'e4'
     */
    function coordsToAlgebraic(coords) {
      return FILES[coords.file] + RANKS[coords.rank];
    }

    /**
     * Valida si una casilla es válida
     * Ejemplo: validSquare('e4') -> true, validSquare('z9') -> false
     */
    function validSquare(square) {
      if (typeof square !== 'string' || square.length !== 2) return false;
      var file = square[0];
      var rank = square[1];
      return FILES.includes(file) && RANKS.includes(rank);
    }

    /**
     * Convierte FEN string a objeto de posición
     * Ejemplo: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR' -> {a1: 'wR', e1: 'wK', ...}
     */
    function fenToPosition(fen) {
      if (fen === 'start') {
        fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
      }

      var position = {};
      var fenParts = fen.split(' ');
      var board = fenParts[0];

      var rank = 7; // Empezar desde el rango 8 (índice 7)
      var file = 0;

      for (var i = 0; i < board.length; i++) {
        var char = board[i];

        if (char === '/') {
          // Nueva fila, resetear file y decrementar rank
          rank--;
          file = 0;
        } else if (isDigit(char)) {
          // Casillas vacías, saltar hacia adelante
          file += parseInt(char);
        } else if (PIECE_TYPES[char]) {
          // Es una pieza válida
          var square = FILES[file] + RANKS[rank];
          var color = char === char.toUpperCase() ? 'w' : 'b';
          var pieceType = PIECE_TYPES[char];
          position[square] = color + pieceType.charAt(0).toUpperCase();
          file++;
        }
      }

      return position;
    }

    /**
     * Verifica si un carácter es un dígito
     */
    function isDigit(char) {
      return /^\d$/.test(char);
    }

    /**
     * Convierte posición a FEN string (simplificado, solo el tablero)
     */
    function positionToFen(position) {
      var fen = '';

      for (var rank = 7; rank >= 0; rank--) {
        var emptySquares = 0;

        for (var file = 0; file < 8; file++) {
          var square = FILES[file] + RANKS[rank];
          var piece = position[square];

          if (piece) {
            // Si hay casillas vacías acumuladas, agregarlas al FEN
            if (emptySquares > 0) {
              fen += emptySquares;
              emptySquares = 0;
            }

            // Agregar la pieza al FEN
            var color = piece[0]; // 'w' o 'b'
            var type = piece[1].toLowerCase(); // 'k', 'q', 'r', etc.
            fen += color === 'w' ? type.toUpperCase() : type;
          } else {
            emptySquares++;
          }
        }

        // Agregar casillas vacías al final del rango si las hay
        if (emptySquares > 0) {
          fen += emptySquares;
        }

        // Agregar separador de rangos (excepto en el último)
        if (rank > 0) {
          fen += '/';
        }
      }

      return fen + ' w - - 0 1'; // Agregar metadatos básicos
    }

    // ============================================
    // FUNCIONES DE RENDERIZADO
    // ============================================

    /**
     * Crea la estructura HTML del tablero
     */
    function createBoard() {
      // Limpiar contenido existente
      state.element.innerHTML = '';
      state.element.className = 'chessboard-cb2';

      // Crear contenedor del tablero
      var boardContainer = document.createElement('div');
      boardContainer.className = 'board-container';

      // Crear contenedor de casillas
      var squaresContainer = document.createElement('div');
      squaresContainer.className = 'squares-container';

      // Crear las 64 casillas
      for (var rank = 7; rank >= 0; rank--) {
        for (var file = 0; file < 8; file++) {
          var square = FILES[file] + RANKS[rank];
          var squareElement = createSquareElement(square, file, rank);
          squaresContainer.appendChild(squareElement);
          state.squares[square] = squareElement;
        }
      }

      boardContainer.appendChild(squaresContainer);
      state.element.appendChild(boardContainer);

      // Agregar coordenadas si está habilitado
      if (state.config.showNotation) {
        addCoordinates();
      }

      console.log('🏁 Chessboard2 tablero creado con 64 casillas');
    }

    /**
     * Crea un elemento de casilla individual
     */
    function createSquareElement(square, file, rank) {
      var squareEl = document.createElement('div');
      var isLight = (file + rank) % 2 === 1;

      squareEl.className = 'square ' + (isLight ? 'light' : 'dark');
      squareEl.id = 'square-' + square;
      squareEl.dataset.square = square;

      // Posicionamiento con CSS Grid (más confiable que flexbox)
      squareEl.style.gridColumn = (file + 1);
      squareEl.style.gridRow = (8 - rank);

      // Eventos de drag & drop si está habilitado
      if (state.config.draggable) {
        setupSquareEvents(squareEl);
      }

      return squareEl;
    }

    /**
     * Configura eventos de drag & drop para una casilla
     */
    function setupSquareEvents(squareEl) {
      // Permitir drop en la casilla
      squareEl.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        squareEl.classList.add('drag-hover');
      });

      squareEl.addEventListener('dragleave', function(e) {
        squareEl.classList.remove('drag-hover');
      });

      squareEl.addEventListener('drop', function(e) {
        e.preventDefault();
        squareEl.classList.remove('drag-hover');

        var targetSquare = squareEl.dataset.square;
        var pieceData = e.dataTransfer.getData('text/plain');

        console.log('🎯 Drop en casilla:', targetSquare, 'Pieza:', pieceData);

        // Llamar callback de drop si existe
        if (state.config.onDrop && typeof state.config.onDrop === 'function') {
          var result = state.config.onDrop(targetSquare, pieceData, 'drop');

          // Si el callback devuelve 'snapback', la pieza regresa a su posición original
          if (result === 'snapback') {
            console.log('⬅️ Snapback: pieza regresada');
            return;
          }
        }

        // Actualizar posición si el drop es válido
        if (pieceData && validSquare(targetSquare)) {
          // Remover pieza de posición anterior si existe
          for (var square in state.position) {
            if (state.position[square] === pieceData) {
              delete state.position[square];
              break;
            }
          }

          // Colocar pieza en nueva posición
          state.position[targetSquare] = pieceData;
          renderPosition();
        }
      });
    }

    /**
     * Agrega coordenadas al tablero (a-h, 1-8)
     */
    function addCoordinates() {
      var boardContainer = state.element.querySelector('.board-container');

      // Coordenadas de archivos (a-h) en la parte inferior
      var filesContainer = document.createElement('div');
      filesContainer.className = 'coordinates files';

      FILES.forEach(function(file) {
        var coord = document.createElement('div');
        coord.className = 'coordinate';
        coord.textContent = file;
        filesContainer.appendChild(coord);
      });

      // Coordenadas de rangos (1-8) en el lateral izquierdo
      var ranksContainer = document.createElement('div');
      ranksContainer.className = 'coordinates ranks';

      RANKS.slice().reverse().forEach(function(rank) {
        var coord = document.createElement('div');
        coord.className = 'coordinate';
        coord.textContent = rank;
        ranksContainer.appendChild(coord);
      });

      boardContainer.appendChild(filesContainer);
      boardContainer.appendChild(ranksContainer);
    }

    /**
     * Renderiza las piezas en sus posiciones actuales
     */
    function renderPosition() {
      // Limpiar todas las piezas existentes
      var existingPieces = state.element.querySelectorAll('.piece');
      existingPieces.forEach(function(piece) {
        piece.remove();
      });

      // Renderizar cada pieza en su posición
      for (var square in state.position) {
        if (state.position.hasOwnProperty(square) && validSquare(square)) {
          var piece = state.position[square];
          renderPiece(square, piece);
        }
      }
    }

    /**
     * Renderiza una pieza individual en una casilla específica
     */
    function renderPiece(square, piece) {
      var squareEl = state.squares[square];
      if (!squareEl) return;

      // Crear elemento de pieza
      var pieceEl = document.createElement('div');
      pieceEl.className = 'piece ' + piece.toLowerCase();
      pieceEl.dataset.piece = piece;

      // Contenido de la pieza (símbolo Unicode por defecto)
      if (typeof state.config.pieceTheme === 'function') {
        // Tema personalizado
        pieceEl.innerHTML = state.config.pieceTheme(piece);
      } else {
        // Tema Unicode por defecto
        pieceEl.textContent = PIECE_SYMBOLS[piece] || '?';
      }

      // Hacer la pieza draggable si está habilitado
      if (state.config.draggable) {
        setupPieceEvents(pieceEl, square, piece);
      }

      // Agregar pieza a la casilla
      squareEl.appendChild(pieceEl);
    }

    /**
     * Configura eventos de drag para una pieza
     */
    function setupPieceEvents(pieceEl, square, piece) {
      pieceEl.draggable = true;

      pieceEl.addEventListener('dragstart', function(e) {
        state.isDragging = true;
        state.draggedPiece = { element: pieceEl, square: square, piece: piece };

        e.dataTransfer.setData('text/plain', piece);
        e.dataTransfer.effectAllowed = 'move';

        // Aplicar estilo de arrastre
        pieceEl.classList.add('dragging');

        console.log('🎯 Drag start:', piece, 'desde', square);

        // Llamar callback si existe
        if (state.config.onDragStart && typeof state.config.onDragStart === 'function') {
          var result = state.config.onDragStart(square, piece);

          // Si el callback devuelve false, prevenir el drag
          if (result === false) {
            e.preventDefault();
            state.isDragging = false;
            state.draggedPiece = null;
            return false;
          }
        }
      });

      pieceEl.addEventListener('dragend', function(e) {
        pieceEl.classList.remove('dragging');
        state.isDragging = false;
        state.draggedPiece = null;

        console.log('🎯 Drag end');

        // Llamar callback si existe
        if (state.config.onSnapEnd && typeof state.config.onSnapEnd === 'function') {
          state.config.onSnapEnd();
        }
      });
    }

    // ============================================
    // API PÚBLICA
    // ============================================

    var api = {
      /**
       * Establecer o obtener la posición del tablero
       * @param {string|Object} position - FEN string o objeto de posición
       * @param {boolean} useAnimation - Usar animación (no implementado en versión simple)
       * @returns {Object|undefined} Posición actual si no se proporciona parámetro
       */
      position: function(position, useAnimation) {
        // Si no se proporciona posición, devolver la actual
        if (arguments.length === 0) {
          return Object.assign({}, state.position);
        }

        // Si se proporciona posición, establecerla
        if (typeof position === 'string') {
          // Es un FEN string
          state.position = fenToPosition(position);
        } else if (typeof position === 'object' && position !== null) {
          // Es un objeto de posición
          state.position = Object.assign({}, position);
        } else if (position === false || position === 'clear') {
          // Limpiar el tablero
          state.position = {};
        }

        // Re-renderizar la posición
        renderPosition();

        console.log('🎯 Posición actualizada:', state.position);
      },

      /**
       * Limpiar el tablero (remover todas las piezas)
       */
      clear: function(useAnimation) {
        api.position({}, useAnimation);
      },

      /**
       * Cambiar orientación del tablero
       * @param {string} color - 'white' o 'black'
       */
      orientation: function(color) {
        if (arguments.length === 0) {
          return state.orientation;
        }

        if (color === 'white' || color === 'black') {
          state.orientation = color;
          state.config.orientation = color;

          // Re-crear el tablero con nueva orientación
          createBoard();
          renderPosition();

          console.log('🎯 Orientación cambiada a:', color);
        }
      },

      /**
       * Redimensionar el tablero
       */
      resize: function() {
        // En esta versión simplificada, solo log
        console.log('🎯 Resize solicitado');
      },

      /**
       * Destruir el tablero y limpiar eventos
       */
      destroy: function() {
        state.element.innerHTML = '';
        state.element.className = '';
        console.log('🎯 Tablero destruido');
      },

      /**
       * Obtener configuración actual
       */
      config: function() {
        return Object.assign({}, state.config);
      }
    };

    // ============================================
    // INICIALIZACIÓN
    // ============================================

    // Crear el tablero inicialmente
    createBoard();

    // Establecer posición inicial
    if (config.position) {
      api.position(config.position);
    }

    console.log('✅ Chessboard2 inicializado correctamente');

    return api;
  }

  // ============================================
  // EXPORTAR LA LIBRERÍA
  // ============================================

  // Exportar para Node.js si está disponible
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Chessboard2;
  }

  // Exportar para navegadores
  if (typeof window !== 'undefined') {
    window.Chessboard2 = Chessboard2;
    // Alias para compatibilidad
    window.Chessboard = Chessboard2;
  }

})();

console.log('📚 Chessboard2.js local cargado');